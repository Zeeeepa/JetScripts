<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stream Chunks with React</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.15/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.12/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.6/dist/purify.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        transition: background-color 0.3s, color 0.3s;
      }
      .dark body {
        background-color: #1a1a1a;
        color: #e5e7eb;
      }
      .dark .bg-gray-100 {
        background-color: #2d2d2d;
      }
      .dark .bg-white {
        background-color: #2d2d2d;
      }
      .dark .text-gray-900 {
        color: #e5e7eb;
      }
      .dark .border-gray-300 {
        border-color: #4b5563;
      }
      .dark .bg-red-100 {
        background-color: #7f1d1d;
      }
      .dark .text-red-700 {
        color: #f87171;
      }
      .dark .bg-blue-500:hover {
        background-color: #2563eb;
      }
      .dark .bg-green-500:hover {
        background-color: #16a34a;
      }
      .dark .bg-gray-500:hover {
        background-color: #4b5563;
      }
      pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        background-color: #f3f4f6;
        padding: 1rem;
        border-radius: 0.5rem;
      }
      .dark pre {
        background-color: #374151;
      }
      .markdown-content {
        prose prose-sm dark:prose-invert;
      }
      .markdown-content p {
        margin-bottom: 1rem;
      }
      .markdown-content strong {
        font-weight: 700;
      }
    </style>
  </head>
  <body class="min-h-screen bg-gray-100 dark:bg-gray-900 font-sans">
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect } = React;

      const StreamApp = () => {
        const [prompts, setPrompts] = useState([
          "Tell a joke.",
          "What is machine learning?",
        ]);
        const [taskId] = useState(crypto.randomUUID());
        const [responses, setResponses] = useState({});
        const [error, setError] = useState(null);
        const [isStreaming, setIsStreaming] = useState(false);
        const [isDarkMode, setIsDarkMode] = useState(
          window.matchMedia("(prefers-color-scheme: dark)").matches
        );
        const [tasks, setTasks] = useState({});
        const [tasksError, setTasksError] = useState(null);

        const toggleDarkMode = () => {
          setIsDarkMode(!isDarkMode);
          document.documentElement.classList.toggle("dark");
        };

        const clearResponses = () => {
          setResponses({});
          setError(null);
        };

        const streamChunks = async () => {
          setIsStreaming(true);
          setError(null);
          setResponses({});
          const payload = {
            model: "llama-3.2-1b-instruct-4bit",
            prompts,
            max_tokens: 100,
            temp: 0.7,
            verbose: true,
            worker_verbose: false,
            task_id: taskId,
          };
          try {
            const response = await fetch("http://localhost:9000/generate", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
              },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              throw new NederlandError(
                `HTTP error! Status: ${response.status}`
              );
            }
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                if (buffer.trim()) {
                  processLine(buffer);
                }
                break;
              }
              buffer += decoder.decode(value, { stream: true });
              const lines = buffer.split("\n");
              buffer = lines.pop();
              for (const line of lines) {
                processLine(line);
              }
            }
          } catch (e) {
            setError(`Streaming error: ${e.message}`);
            console.error(`Streaming error: ${e.message}`);
          } finally {
            setIsStreaming(false);
          }

          function processLine(line) {
            if (!line.trim()) return;
            console.log(`Received: ${line}`);
            try {
              const data = JSON.parse(line);
              if (data.type === "chunk") {
                console.log(`Chunk [${data.prompt_id}]: ${data.content}`);
                setResponses((prev) => {
                  const newResponses = { ...prev };
                  if (!newResponses[data.prompt_id]) {
                    newResponses[data.prompt_id] = {
                      prompt: data.prompt,
                      content: "",
                      rawContent: "",
                      truncated: false,
                    };
                  }
                  const prevContent = newResponses[data.prompt_id].rawContent;
                  const newContent = data.content;
                  const needsSpace =
                    prevContent &&
                    !prevContent.match(/[\s.,!?]$/) &&
                    !newContent.match(/^[\s.,!?]/);
                  newResponses[data.prompt_id].rawContent +=
                    (needsSpace ? " " : "") + newContent;
                  newResponses[data.prompt_id].content = marked.parse(
                    newResponses[data.prompt_id].rawContent,
                    { breaks: true }
                  );
                  return newResponses;
                });
              } else if (data.type === "result") {
                console.log(
                  `Result [${data.prompt_id}]: Truncated=${data.truncated}`
                );
                setResponses((prev) => ({
                  ...prev,
                  [data.prompt_id]: {
                    ...prev[data.prompt_id],
                    truncated: data.truncated,
                  },
                }));
              } else if (data.type === "error") {
                console.error(`Error [${data.prompt_id}]: ${data.message}`);
                setError(`Server error: ${data.message}`);
              } else {
                console.warn(`Unknown message type: ${data.type}`);
              }
            } catch (e) {
              console.error(`Invalid JSON chunk: ${line}`);
              setError(`Invalid JSON chunk: ${line}`);
            }
          }
        };

        const fetchTasks = async () => {
          try {
            const response = await fetch("http://localhost:9000/tasks", {
              method: "GET",
              headers: {
                Accept: "application/json",
              },
            });
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const data = await response.json();
            setTasks(data.tasks);
            setTasksError(null);
          } catch (e) {
            setTasksError(`Failed to fetch tasks: ${e.message}`);
            console.error(`Failed to fetch tasks: ${e.message}`);
          }
        };

        useEffect(() => {
          if (isDarkMode) {
            document.documentElement.classList.add("dark");
          } else {
            document.documentElement.classList.remove("dark");
          }
        }, [isDarkMode]);

        useEffect(() => {
          fetchTasks(); // Initial fetch
          const interval = setInterval(fetchTasks, 2000); // Poll every 2 seconds
          return () => clearInterval(interval); // Cleanup on unmount
        }, []);

        const handlePromptChange = (index, value) => {
          const newPrompts = [...prompts];
          newPrompts[index] = value;
          setPrompts(newPrompts);
        };

        const addPrompt = () => {
          setPrompts([...prompts, ""]);
        };

        const getStatusColor = (status) => {
          switch (status) {
            case "pending":
              return "text-yellow-600 dark:text-yellow-400";
            case "processing":
              return "text-blue-600 dark:text-blue-400";
            case "completed":
              return "text-green-600 dark:text-green-400";
            case "failed":
              return "text-red-600 dark:text-red-400";
            default:
              return "text-gray-600 dark:text-gray-400";
          }
        };

        return (
          <div className="container mx-auto px-4 py-8 max-w-3xl">
            <header className="flex justify-between items-center mb-8">
              <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
                Stream Chunks
              </h1>
              <button
                onClick={toggleDarkMode}
                className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 transition"
                aria-label="Toggle dark mode"
              >
                {isDarkMode ? (
                  <svg
                    className="w-6 h-6"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
                    />
                  </svg>
                ) : (
                  <svg
                    className="w-6 h-6"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
                    />
                  </svg>
                )}
              </button>
            </header>
            <section className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">
                Task ID: {taskId}
              </h2>
              <div className="space-y-4">
                {prompts.map((prompt, index) => (
                  <div key={index} className="flex items-center space-x-2">
                    <input
                      type="text"
                      value={prompt}
                      onChange={(e) =>
                        handlePromptChange(index, e.target.value)
                      }
                      className="flex-1 p-3 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 transition"
                      placeholder="Enter a prompt"
                      disabled={isStreaming}
                      aria-label={`Prompt ${index + 1}`}
                    />
                  </div>
                ))}
                <div className="flex space-x-2">
                  <button
                    onClick={addPrompt}
                    className="bg-blue-500 dark:bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-600 dark:hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isStreaming}
                    aria-label="Add new prompt"
                  >
                    Add Prompt
                  </button>
                  <button
                    onClick={streamChunks}
                    className="bg-green-500 dark:bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-600 dark:hover:bg-green-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isStreaming || prompts.some((p) => !p)}
                    aria-label="Start streaming"
                  >
                    {isStreaming ? "Streaming..." : "Start Streaming"}
                  </button>
                  <button
                    onClick={clearResponses}
                    className="bg-gray-500 dark:bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-600 dark:hover:bg-gray-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={
                      isStreaming || Object.keys(responses).length === 0
                    }
                    aria-label="Clear responses"
                  >
                    Clear Responses
                  </button>
                </div>
              </div>
            </section>
            {error && (
              <div className="bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300 p-4 rounded-lg mb-6">
                Error: {error}
              </div>
            )}
            <section className="mb-6">
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">
                Current Tasks
              </h2>
              {tasksError && (
                <div className="bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300 p-4 rounded-lg mb-4">
                  Error: {tasksError}
                </div>
              )}
              {Object.keys(tasks).length === 0 && !tasksError && (
                <div className="text-gray-700 dark:text-gray-300 p-4">
                  No tasks currently running.
                </div>
              )}
              {Object.entries(tasks).map(([taskId, task]) => (
                <div
                  key={taskId}
                  className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-4"
                >
                  <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                    Task ID: {taskId}
                  </h3>
                  <p className="text-gray-700 dark:text-gray-300">
                    <strong>Model:</strong> {task.model}
                  </p>
                  <p className="text-gray-700 dark:text-gray-300">
                    <strong>Type:</strong> {task.is_chat ? "Chat" : "Generate"}{" "}
                    {task.stream ? "(Streaming)" : "(Non-Streaming)"}
                  </p>
                  <p className="text-gray-700 dark:text-gray-300">
                    <strong>Status:</strong>{" "}
                    <span className={getStatusColor(task.status)}>
                      {task.status}
                    </span>
                  </p>
                  <p className="text-gray-700 dark:text-gray-300">
                    <strong>Created At:</strong>{" "}
                    {new Date(task.created_at * 1000).toLocaleString()}
                  </p>
                  <h4 className="text-md font-semibold text-gray-900 dark:text-white mt-4">
                    Prompts
                  </h4>
                  <div className="mt-2 space-y-2">
                    {Object.entries(task.prompts).map(
                      ([promptId, promptData]) => (
                        <div
                          key={promptId}
                          className="p-3 bg-gray-50 dark:bg-gray-700 rounded-lg"
                        >
                          <p className="text-gray-700 dark:text-gray-300">
                            <strong>Prompt ID:</strong> {promptId}
                          </p>
                          <p className="text-gray-700 dark:text-gray-300">
                            <strong>Prompt:</strong> {promptData.prompt}
                          </p>
                          <p className="text-gray-700 dark:text-gray-300">
                            <strong>Status:</strong>{" "}
                            <span className={getStatusColor(promptData.status)}>
                              {promptData.status}
                            </span>
                          </p>
                          {promptData.error && (
                            <p className="text-red-600 dark:text-red-400">
                              <strong>Error:</strong> {promptData.error}
                            </p>
                          )}
                        </div>
                      )
                    )}
                  </div>
                </div>
              ))}
            </section>
            <section>
              <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">
                Responses
              </h2>
              {isStreaming && Object.keys(responses).length === 0 && (
                <div className="text-gray-700 dark:text-gray-300 p-4">
                  Loading responses...
                </div>
              )}
              {Object.entries(responses).map(
                ([promptId, { prompt, content, rawContent, truncated }]) => (
                  <div
                    key={promptId}
                    className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-4"
                  >
                    <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                      Prompt ID: {promptId}
                    </h3>
                    <p className="text-gray-700 dark:text-gray-300">
                      <strong>Prompt:</strong> {prompt}
                    </p>
                    <p className="text-gray-700 dark:text-gray-300">
                      <strong>Response:</strong>
                      <div
                        className="markdown-content mt-2 text-gray-700 dark:text-gray-300"
                        dangerouslySetInnerHTML={{
                          __html: DOMPurify.sanitize(content),
                        }}
                      />
                      {content === rawContent && (
                        <pre className="mt-2">{rawContent}</pre>
                      )}
                    </p>
                    {truncated && (
                      <p className="text-yellow-600 dark:text-yellow-400 mt-2">
                        Warning: Response was truncated due to max_tokens limit.
                      </p>
                    )}
                  </div>
                )
              )}
            </section>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<StreamApp />);
    </script>
  </body>
</html>
