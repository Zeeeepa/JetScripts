[
  "### 5.\nCore Component: Text Chunking Function\nLLMs and embedding models have limits on the amount of text they can process at once.\nFurthermore, retrieval works best when searching over smaller, focused pieces of text rather than entire large documents.\n**Chunking** is the process of splitting large documents into smaller, potentially overlapping, segments.\n- **`chunk_size`**: Determines the approximate size (here, in words) of each chunk.\n- **`chunk_overlap`**: Specifies how many words from the end of one chunk should also be included at the beginning of the next chunk.\nThis helps prevent relevant information from being lost if it spans across the boundary between two chunks.\nWe define a function `chunk_text` to perform this splitting based on word counts.\n### 5.\nCore Component: Text Chunking Function\nCode:\ndef chunk_text(text, chunk_size, chunk_overlap):\n\"\"\"Splits a single text document into overlapping chunks based on word count.\nArgs:\ntext (str): The input text to be chunked.\nchunk_size (int): The target number of words per chunk.\nchunk_overlap (int): The number of words to overlap between consecutive chunks.\nReturns:\nlist[str]: A list of text chunks.\n\"\"\"",
  "### 5. Core Component: Text Chunking Function - 15 words = text.split()      # Split the text into a list of individual words\ntotal_words = len(words) # Calculate the total number of words in the text\nchunks = []             # Initialize an empty list to store the generated chunks\nstart_index = 0         # Initialize the starting word index for the first chunk\n# --- Input Validation ---\n# Ensure chunk_size is a positive integer.\nif not isinstance(chunk_size, int) or chunk_size <= 0:\nprint(f\"  Warning: Invalid chunk_size ({chunk_size}). Must be a positive integer. Returning the whole text as one chunk.\")\nreturn [text]\n# Ensure chunk_overlap is a non-negative integer smaller than chunk_size.\nif not isinstance(chunk_overlap, int) or chunk_overlap < 0:\nprint(f\"  Warning: Invalid chunk_overlap ({chunk_overlap}). Must be a non-negative integer. Setting overlap to 0.\")\nchunk_overlap = 0\nif chunk_overlap >= chunk_size:\n# If overlap is too large, adjust it to a reasonable fraction (e.g., 1/3) of chunk_size\n# This prevents infinite loops or nonsensical chunking.\nadjusted_overlap = chunk_size // 3\nprint(f\"  Warning: chunk_overlap ({chunk_overlap}) >= chunk_size ({chunk_size}). Adjusting overlap to {adjusted_overlap}.\")\nchunk_overlap = adjusted_overlap\n# --- Chunking Loop ---",
  "# Continue chunking as long as the start_index is within the bounds of the text\nwhile start_index < total_words:\n# Determine the end index for the current chunk.\n# It's the minimum of (start + chunk_size) and the total number of words.\nend_index = min(start_index + chunk_size, total_words)\n# Extract the words for the current chunk and join them back into a single string.\ncurrent_chunk_text = \" \".join(words[start_index:end_index])\nchunks.append(current_chunk_text) # Add the generated chunk to the list\n# Calculate the starting index for the *next* chunk.\n# Move forward by (chunk_size - chunk_overlap) words.\nnext_start_index = start_index + chunk_size - chunk_overlap\n# --- Safety Checks ---\n# Check 1: Prevent infinite loops if overlap causes no progress.\n# This can happen if chunk_size is very small or overlap is very large relative to chunk_size.\nif next_start_index <= start_index:\nif end_index == total_words: # If we are already at the end, we can safely break.\nbreak\nelse:\n# Force progress by moving forward by at least one word.\nprint(f\"  Warning: Chunking logic stuck (start={start_index}, next_start={next_start_index}). Forcing progress.\")\nnext_start_index = start_index + 1",
  "# Check 2: If the calculated next start index is already at or beyond the total number of words, we are done.\nif next_start_index >= total_words:\nbreak\n# Move the start_index to the calculated position for the next iteration.\nstart_index = next_start_index\nreturn chunks # Return the complete list of text chunks\n# --- Quick Test ---\n# Test the function with the first document and sample parameters.\nprint(\"Defining the 'chunk_text' function.\")\nsample_chunk_size = 150\nsample_overlap = 30\nsample_chunks = chunk_text(corpus_texts[0], sample_chunk_size, sample_overlap)\nprint(f\"Test chunking on first doc (size={sample_chunk_size} words, overlap={sample_overlap} words): Created {len(sample_chunks)} chunks.\")\nif sample_chunks: # Only print if chunks were created\nprint(f\"First sample chunk:n'{sample_chunks[0]}'\")\nprint(\"-\" * 25)",
  "### Table of Contents\n1.  **Setup: Installing Libraries**: Get the necessary tools.\n2.  **Setup: Importing Libraries**: Bring the tools into our workspace.\n3.  **Configuration: Setting Up Our Experiment**: Define API details, models, evaluation prompts, and parameters to test.\n4.  **Input Data: The Knowledge Source & Our Question**: Define the documents the RAG system will learn from and the question we'll ask.\n5.  **Core Component: Text Chunking Function**: Create a function to break documents into smaller pieces.\n6.  **Core Component: Connecting to Nebius AI**: Establish the connection to use Nebius models.\n7.  **Core Component: Cosine Similarity Function**: Create a function to measure semantic similarity between texts.\n8.  **The Experiment: Iterating Through Configurations**: The main loop where we test different settings.\n*   8.1 Processing a Chunking Configuration (Chunk, Embed, Index)\n*   8.2 Testing RAG Strategies for a `top_k` Value\n*   8.3 Running & Evaluating a Single RAG Strategy (including Similarity)\n9.  **Analysis: Reviewing the Results**: Use Pandas to organize and display the results.\n10. **Conclusion: What Did We Learn?**: Reflect on the findings and potential next steps.\n### 8.\nThe Experiment: Iterating Through Configurations\nThis section contains the main experimental loop.",
  "### 8. The Experiment: Iterating Through Configurations - 3 We will systematically iterate through all combinations of the tuning parameters we defined earlier (`CHUNK_SIZES_TO_TEST`, `CHUNK_OVERLAPS_TO_TEST`, `RETRIEVAL_TOP_K_TO_TEST`).\n**Workflow for Each Parameter Combination:**\n1.\n**Prepare Data (Chunking/Embedding/Indexing - Step 8.1):**\n*   **Check if Re-computation Needed:** If the `chunk_size` or `chunk_overlap` has changed from the previous iteration, we need to re-process the corpus.\n*   **Chunking:** Split all documents in `corpus_texts` using the current `chunk_size` and `chunk_overlap` via the `chunk_text` function.\n*   **Embedding:** Convert each text chunk into a numerical vector (embedding) using the specified Nebius embedding model (`NEBIUS_EMBEDDING_MODEL`).\nWe do this in batches for efficiency.\n*   **Indexing:** Build a FAISS index (`IndexFlatL2`) from the generated embeddings.\nFAISS allows for very fast searching to find the chunks whose embeddings are most similar to the query embedding.\n*   *Optimization:* If chunk settings haven't changed, we reuse the existing chunks, embeddings, and index from the previous iteration to save time and API calls.",
  "### 8. The Experiment: Iterating Through Configurations - 12 2. **Test RAG Strategies (Step 8.2):**\n*   For the current `top_k` value, run each of the defined RAG strategies:\n*   **Simple RAG:** Retrieve `top_k` chunks based on similarity to the original query.\n*   **Query Rewrite RAG:** First, ask the LLM to rewrite the original query to be potentially better for vector search.\nThen, retrieve `top_k` chunks based on similarity to the *rewritten* query.\n*   **Rerank RAG (Simulated):** Retrieve more chunks initially (`top_k * RERANK_RETRIEVAL_MULTIPLIER`).\nThen, *simulate* reranking by simply taking the top `top_k` results from this larger initial set.\n(A real implementation would use a more sophisticated reranking model).\n3. **Evaluate & Store Results (Step 8.3 within `run_and_evaluate`):**\n*   For each strategy run:\n*   **Retrieve:** Find the relevant chunk indices using the FAISS index.\n*   **Generate:** Construct a prompt containing the retrieved chunk(s) as context and the *original* `test_query`.\nSend this to the Nebius generation model (`NEBIUS_GENERATION_MODEL`) to get the final answer.",
  "### 8. The Experiment: Iterating Through Configurations - 21 *   **Evaluate (Faithfulness):** Use the LLM evaluator (`NEBIUS_EVALUATION_MODEL`) with the `FAITHFULNESS_PROMPT` to score how well the generated answer aligns with the `true_answer_for_query`.\n*   **Evaluate (Relevancy):** Use the LLM evaluator with the `RELEVANCY_PROMPT` to score how well the generated answer addresses the `test_query`.\n*   **Evaluate (Similarity):** Use our `calculate_cosine_similarity` function to get the semantic similarity score between the generated answer and the `true_answer_for_query`.\n*   **Calculate Average Score:** Compute the average of Faithfulness, Relevancy, and Similarity scores.\n*   **Record:** Store all parameters (`chunk_size`, `overlap`, `top_k`, `strategy`), the retrieved indices, the rewritten query (if applicable), the generated answer, the individual scores, the average score, and the execution time for this specific run.\nWe use `tqdm` to display a progress bar for the outer loop iterating through parameter combinations.\n### 10.\nConclusion: What Did We Learn?\nWe have successfully constructed and executed an end-to-end pipeline to experiment with various RAG configurations and evaluate their performance using multiple metrics on the Nebius AI platform.\nBy examining the results table and the best configuration summary above, we can gain insights specific to *our chosen corpus, query, and models*.",
  "### 10. Conclusion: What Did We Learn? - 5 **Reflection Points:**\n*   **Chunking Impact:** Did a specific `chunk_size` or `overlap` tend to produce better average scores?\nConsider why smaller chunks might capture specific facts better, while larger chunks might provide more context.\nHow did overlap seem to influence the results?\n*   **Retrieval Quantity (`top_k`):** How did increasing `top_k` affect the scores?\nDid retrieving more chunks always lead to better answers, or did it sometimes introduce noise or irrelevant information, potentially lowering faithfulness or similarity?\n*   **Strategy Comparison:** Did the 'Query Rewrite' or 'Rerank (Simulated)' strategies offer a consistent advantage over 'Simple RAG' in terms of the average score?\nWas the potential improvement significant enough to justify the extra steps (e.g., additional LLM call for rewrite, larger initial retrieval for rerank)?\n*   **Evaluation Metrics:**\n*   Look at the 'Best Answer' and compare it to the `true_answer_for_query`.\nDo the individual scores (Faithfulness, Relevancy, Similarity) seem to reflect the quality you perceive?\n*   Did high similarity always correlate with high faithfulness?\nCould an answer be similar but unfaithful, or faithful but dissimilar?\n*   How reliable do you feel the automated LLM evaluation (Faithfulness, Relevancy) is compared to the more objective Cosine Similarity?",
  "### 10. Conclusion: What Did We Learn? - 17 What are the potential limitations of LLM-based evaluation (e.g., sensitivity to prompt wording, model biases)?\n*   **Overall Performance:** Did any configuration achieve a near-perfect average score?\nWhat might be preventing a perfect score (e.g., limitations of the source documents, inherent ambiguity in language, imperfect retrieval)?\n**Key Takeaway:** Optimizing a RAG system is an iterative process.\nThe best configuration often depends heavily on the specific dataset, the nature of the user queries, the chosen embedding and LLM models, and the evaluation criteria.\nSystematic experimentation, like the process followed in this notebook, is crucial for finding settings that perform well for a particular use case.\n**Potential Next Steps & Further Exploration:**\n*   **Expand Test Parameters:** Try a wider range of `chunk_size`, `overlap`, and `top_k` values.\n*   **Different Queries:** Test the same configurations with different types of queries (e.g., fact-based, comparison, summarization) to see how performance varies.\n*   **Larger/Different Corpus:** Use a more extensive or domain-specific knowledge base.\n*   **Implement True Reranking:** Replace the simulated reranking with a dedicated cross-encoder reranking model (e.g., from Hugging Face Transformers or Cohere Rerank) to re-score the initially retrieved documents based on relevance.\n*   **Alternative Models:** Experiment with different Nebius AI models for embedding, generation, or evaluation to see their impact.",
  "### 10. Conclusion: What Did We Learn? - 28 *   **Advanced Chunking:** Explore more sophisticated chunking strategies (e.g., recursive character splitting, semantic chunking).\n*   **Human Evaluation:** Complement the automated metrics with human judgment for a more nuanced understanding of answer quality.\n### 4. Input Data: The Knowledge Source & Our Question\nEvery RAG system needs a knowledge base to draw information from. Here, we define:\n*   `corpus_texts`: A list of strings, where each string is a document containing information (in this case, about renewable energy sources).\n*   `test_query`: The specific question we want the RAG system to answer using the `corpus_texts`.\n*   `true_answer_for_query`: A carefully crafted 'ground truth' answer based *only* on the information available in `corpus_texts`. This is essential for evaluating Faithfulness and Semantic Similarity accurately.\n### 8. The Experiment: Iterating Through Configurations\nCode:\n# List to store the detailed results from each experimental run\nall_results = []\n# --- Cache variables for Chunking/Embedding/Indexing ---",
  "# These variables help us avoid redundant computations when only 'top_k' changes.\nlast_chunk_size = -1      # Stores the chunk_size used in the previous iteration\nlast_overlap = -1         # Stores the chunk_overlap used in the previous iteration\ncurrent_index = None      # Holds the active FAISS index\ncurrent_chunks = []       # Holds the list of text chunks for the active settings\ncurrent_embeddings = None # Holds the numpy array of embeddings for the active chunks\n# Check if the Nebius client was initialized successfully before starting\nif not client:\nprint(\"STOPPING: Nebius AI client is not initialized. Cannot run experiment.\")\nelse:\nprint(\"=== Starting RAG Experiment Loop ===n\")\n# Create all possible combinations of the tuning parameters\nparam_combinations = list(itertools.product(\nCHUNK_SIZES_TO_TEST,\nCHUNK_OVERLAPS_TO_TEST,\nRETRIEVAL_TOP_K_TO_TEST\n))\nprint(f\"Total parameter combinations to test: {len(param_combinations)}\")\n# --- Main Loop ---\n# Iterate through each combination (chunk_size, chunk_overlap, top_k)\n# Use tqdm to display a progress bar.\nfor chunk_size, chunk_overlap, top_k in tqdm(param_combinations, desc=\"Testing Configurations\"):\n# --- 8.1 Processing a Chunking Configuration ---\n# Check if chunk settings have changed, requiring re-processing.\nif chunk_size != last_chunk_size or chunk_overlap != last_overlap:",
  "# Uncomment the line below for more verbose logging during execution\n# print(f\"n--- Processing New Chunk Config: Size={chunk_size}, Overlap={chunk_overlap} ---\")\n# Update cache variables\nlast_chunk_size, last_overlap = chunk_size, chunk_overlap\n# Reset index, chunks, and embeddings for the new configuration\ncurrent_index = None\ncurrent_chunks = []\ncurrent_embeddings = None\n# --- 8.1a: Chunking ---\n# Apply the chunk_text function to each document in the corpus\ntry:\n# print(\"  Chunking documents...\") # Uncomment for verbose logging\ntemp_chunks = []\nfor doc_index, doc in enumerate(corpus_texts):\ndoc_chunks = chunk_text(doc, chunk_size, chunk_overlap)\nif not doc_chunks:\nprint(f\"  Warning: No chunks created for document {doc_index} with size={chunk_size}, overlap={chunk_overlap}. Skipping document.\")\ncontinue\ntemp_chunks.extend(doc_chunks)\ncurrent_chunks = temp_chunks\nif not current_chunks:\n# If no chunks were created at all (e.g., due to invalid settings or empty corpus)\nraise ValueError(\"No chunks were created for the current configuration.\")",
  "# print(f\"    Created {len(current_chunks)} chunks total.\") # Uncomment for verbose logging\nexcept Exception as e:\nprint(f\"    ERROR during chunking for Size={chunk_size}, Overlap={chunk_overlap}: {e}. Skipping this configuration.\")\nlast_chunk_size, last_overlap = -1, -1 # Reset cache state\ncontinue # Move to the next parameter combination\n# --- 8.1b: Embedding ---\n# Generate embeddings for all chunks using the Nebius API.\n# print(\"  Generating embeddings...\") # Uncomment for verbose logging\ntry:\nbatch_size = 32 # Process chunks in batches to avoid overwhelming the API or hitting limits.\ntemp_embeddings = [] # Temporary list to store embedding vectors\n# Loop through chunks in batches\nfor i in range(0, len(current_chunks), batch_size):\nbatch_texts = current_chunks[i : min(i + batch_size, len(current_chunks))]\n# Make the API call to Nebius for the current batch\nresponse = client.embeddings.create(model=NEBIUS_EMBEDDING_MODEL, input=batch_texts)\n# Extract the embedding vectors from the API response\nbatch_embeddings = [item.embedding for item in response.data]\ntemp_embeddings.extend(batch_embeddings)\ntime.sleep(0.05) # Add a small delay between batches to be polite to the API endpoint.\n# Convert the list of embeddings into a single NumPy array\ncurrent_embeddings = np.array(temp_embeddings)",
  "# Basic validation check on the embeddings array\nif current_embeddings.ndim != 2 or current_embeddings.shape[0] != len(current_chunks):\nraise ValueError(f\"Embeddings array shape mismatch. Expected ({len(current_chunks)}, dim), Got {current_embeddings.shape}\")\n# print(f\"    Generated {current_embeddings.shape[0]} embeddings (Dimension: {current_embeddings.shape[1]}).\") # Uncomment for verbose logging\nexcept Exception as e:\nprint(f\"    ERROR generating embeddings for Size={chunk_size}, Overlap={chunk_overlap}: {e}. Skipping this chunk config.\")\n# Reset cache variables to indicate failure for this chunk setting\nlast_chunk_size, last_overlap = -1, -1\ncurrent_chunks = []\ncurrent_embeddings = None\ncontinue # Skip to the next parameter combination\n# --- 8.1c: Indexing ---\n# Build a FAISS index for efficient similarity search.\n# print(\"  Building FAISS search index...\") # Uncomment for verbose logging\ntry:\nembedding_dim = current_embeddings.shape[1] # Get the dimensionality of the embeddings\n# We use IndexFlatL2, which performs exact search using L2 (Euclidean) distance.\n# For high-dimensional vectors from modern embedding models, cosine similarity often works better,\n# but FAISS's IndexFlatIP (Inner Product) is closely related. For normalized embeddings (like many BGE models),",
  "# L2 distance and Inner Product/Cosine Similarity ranking are equivalent.\ncurrent_index = faiss.IndexFlatL2(embedding_dim)\n# Add the chunk embeddings to the index. FAISS requires float32 data type.\ncurrent_index.add(current_embeddings.astype('float32'))\nif current_index.ntotal == 0:\nraise ValueError(\"FAISS index is empty after adding vectors. No vectors were added.\")\n# print(f\"    FAISS index ready with {current_index.ntotal} vectors.\") # Uncomment for verbose logging\nexcept Exception as e:\nprint(f\"    ERROR building FAISS index for Size={chunk_size}, Overlap={chunk_overlap}: {e}. Skipping this chunk config.\")\n# Reset variables to indicate failure\nlast_chunk_size, last_overlap = -1, -1\ncurrent_index = None\ncurrent_embeddings = None\ncurrent_chunks = []\ncontinue # Skip to the next parameter combination\n# --- 8.2 Testing RAG Strategies for the Current Top-K ---\n# If we reach this point, we have a valid index and chunks for the current chunk_size/overlap.\n# Check if the index and chunks are actually available (safety check)\nif current_index is None or not current_chunks:\nprint(f\"    WARNING: Index or chunks not available for Size={chunk_size}, Overlap={chunk_overlap}. Skipping Top-K={top_k} test.\")\ncontinue\n# --- 8.3 Running & Evaluating a Single RAG Strategy ---",
  "# Define a nested function to perform the core RAG steps (retrieve, generate, evaluate)\n# This avoids code repetition for each strategy.\ndef run_and_evaluate(strategy_name, query_to_use, k_retrieve, use_simulated_rerank=False):\n# print(f\"    Starting: {strategy_name} (k={k_retrieve}) ...\") # Uncomment for verbose logging\nrun_start_time = time.time() # Record start time for timing the run\n# Initialize a dictionary to store results for this specific run\nresult = {\n'chunk_size': chunk_size, 'overlap': chunk_overlap, 'top_k': k_retrieve,\n'strategy': strategy_name,\n'retrieved_indices': [], 'rewritten_query': None, 'answer': 'Error: Execution Failed',\n'faithfulness': 0.0, 'relevancy': 0.0, 'similarity_score': 0.0, 'avg_score': 0.0,\n'time_sec': 0.0\n}\n# Store the rewritten query if applicable\nif strategy_name == \"Query Rewrite RAG\":\nresult['rewritten_query'] = query_to_use\ntry:\n# --- Retrieval Step ---\nk_for_search = k_retrieve # Number of chunks to retrieve initially\nif use_simulated_rerank:\n# For simulated rerank, retrieve more candidates initially\nk_for_search = k_retrieve * RERANK_RETRIEVAL_MULTIPLIER",
  "# print(f\"      Rerank: Retrieving initial {k_for_search} candidates.\") # Uncomment for verbose logging\n# 1. Embed the query (original or rewritten)\nquery_embedding_response = client.embeddings.create(model=NEBIUS_EMBEDDING_MODEL, input=[query_to_use])\nquery_embedding = query_embedding_response.data[0].embedding\nquery_vector = np.array([query_embedding]).astype('float32') # FAISS needs float32 numpy array\n# 2. Perform the search in the FAISS index\n# Ensure k is not greater than the total number of items in the index\nactual_k = min(k_for_search, current_index.ntotal)\nif actual_k == 0:\nraise ValueError(\"Index is empty or k_for_search is zero, cannot search.\")\n# `current_index.search` returns distances and indices of the nearest neighbors\ndistances, indices = current_index.search(query_vector, actual_k)\n# 3. Process retrieved indices\n# Indices can contain -1 if fewer than 'actual_k' vectors are found (shouldn't happen with IndexFlatL2 unless k > ntotal)\nretrieved_indices_all = indices[0]\nvalid_indices = retrieved_indices_all[retrieved_indices_all != -1].tolist()\n# 4. Apply simulated reranking (if applicable)\n# In this simulation, we just take the top 'k_retrieve' results from the initially retrieved set.",
  "# A real reranker would re-score these 'k_for_search' candidates based on relevance to the query.\nif use_simulated_rerank:\nfinal_indices = valid_indices[:k_retrieve]\n# print(f\"      Rerank: Selected top {len(final_indices)} indices after simulated rerank.\") # Uncomment for verbose logging\nelse:\nfinal_indices = valid_indices # Use all valid retrieved indices up to k_retrieve\nresult['retrieved_indices'] = final_indices\n# 5. Get the actual text chunks corresponding to the final indices\nretrieved_chunks = [current_chunks[i] for i in final_indices]\n# Handle case where no chunks were retrieved (should be rare with valid indices)\nif not retrieved_chunks:\nprint(f\"      Warning: No relevant chunks found for {strategy_name} (C={chunk_size}, O={chunk_overlap}, K={k_retrieve}). Setting answer to indicate this.\")\nresult['answer'] = \"No relevant context found in the documents based on the query.\"\n# Keep scores at 0.0 as no answer was generated from context\nelse:\n# --- Generation Step ---\n# Combine the retrieved chunks into a single context string\ncontext_str = \"nn\".join(retrieved_chunks)",
  "# Define the system prompt for the generation LLM\nsys_prompt_gen = \"You are a helpful AI assistant. Answer the user's query based strictly on the provided context. If the context doesn't contain the answer, state that clearly. Be concise.\"\n# Construct the user prompt including the context and the *original* query\n# It's important to use the original query here for generating the final answer, even if a rewritten query was used for retrieval.\nuser_prompt_gen = f\"Context:n------n{context_str}n------nnQuery: {test_query}nnAnswer:\"\n# Make the API call to the Nebius generation model\ngen_response = client.chat.completions.create(\nmodel=NEBIUS_GENERATION_MODEL,\nmessages=[\n{\"role\": \"system\", \"content\": sys_prompt_gen},\n{\"role\": \"user\", \"content\": user_prompt_gen}\n],\ntemperature=GENERATION_TEMPERATURE,\nmax_tokens=GENERATION_MAX_TOKENS,\ntop_p=GENERATION_TOP_P\n)\n# Extract the generated text answer\ngenerated_answer = gen_response.choices[0].message.content.strip()\nresult['answer'] = generated_answer\n# Optional: print a snippet of the generated answer\n# print(f\"      Generated Answer: {generated_answer[:100].replace('n', ' ')}...\")\n# --- Evaluation Step ---\n# Evaluate the generated answer using Faithfulness, Relevancy, and Similarity",
  "# print(f\"      Evaluating answer... (Faithfulness, Relevancy, Similarity)\") # Uncomment for verbose logging\n# Prepare parameters for evaluation calls (use low temperature for deterministic scoring)\neval_params = {'model': NEBIUS_EVALUATION_MODEL, 'temperature': 0.0, 'max_tokens': 10}\n# 1. Faithfulness Evaluation Call\nprompt_f = FAITHFULNESS_PROMPT.format(question=test_query, response=generated_answer, true_answer=true_answer_for_query)\ntry:\nresp_f = client.chat.completions.create(messages=[{\"role\": \"user\", \"content\": prompt_f}], **eval_params)\n# Attempt to parse the score, clamp between 0.0 and 1.0\nresult['faithfulness'] = max(0.0, min(1.0, float(resp_f.choices[0].message.content.strip())))\nexcept Exception as eval_e:\nprint(f\"      Warning: Faithfulness score parsing error for {strategy_name} - {eval_e}. Score set to 0.0\")\nresult['faithfulness'] = 0.0\n# 2. Relevancy Evaluation Call\nprompt_r = RELEVANCY_PROMPT.format(question=test_query, response=generated_answer)\ntry:\nresp_r = client.chat.completions.create(messages=[{\"role\": \"user\", \"content\": prompt_r}], **eval_params)",
  "# Attempt to parse the score, clamp between 0.0 and 1.0\nresult['relevancy'] = max(0.0, min(1.0, float(resp_r.choices[0].message.content.strip())))\nexcept Exception as eval_e:\nprint(f\"      Warning: Relevancy score parsing error for {strategy_name} - {eval_e}. Score set to 0.0\")\nresult['relevancy'] = 0.0\n# 3. Similarity Score Calculation\nresult['similarity_score'] = calculate_cosine_similarity(\ngenerated_answer,\ntrue_answer_for_query,\nclient,\nNEBIUS_EMBEDDING_MODEL\n)\n# 4. Calculate Average Score (Faithfulness, Relevancy, Similarity)\nresult['avg_score'] = (result['faithfulness'] + result['relevancy'] + result['similarity_score']) / 3.0\nexcept Exception as e:\n# Catch any unexpected errors during the retrieve/generate/evaluate process\nerror_message = f\"ERROR during {strategy_name} (C={chunk_size}, O={chunk_overlap}, K={k_retrieve}): {str(e)[:200]}...\"\nprint(f\"    {error_message}\")\nresult['answer'] = error_message # Store the error in the answer field",
  "# Ensure scores remain at their default error state (0.0)\nresult['faithfulness'] = 0.0\nresult['relevancy'] = 0.0\nresult['similarity_score'] = 0.0\nresult['avg_score'] = 0.0\n# Record the total time taken for this run\nrun_end_time = time.time()\nresult['time_sec'] = run_end_time - run_start_time\n# Print a summary line for this run (useful for monitoring progress)\nprint(f\"    Finished: {strategy_name} (C={chunk_size}, O={chunk_overlap}, K={k_retrieve}). AvgScore={result['avg_score']:.2f}, Time={result['time_sec']:.2f}s\")\nreturn result\n# --- End of run_and_evaluate nested function ---\n# --- Execute the RAG Strategies using the run_and_evaluate function ---\n# Strategy 1: Simple RAG (Use original query for retrieval)\nresult_simple = run_and_evaluate(\"Simple RAG\", test_query, top_k)\nall_results.append(result_simple)\n# Strategy 2: Query Rewrite RAG\nrewritten_q = test_query # Default to original query if rewrite fails\ntry:\n# print(\"    Attempting query rewrite for Rewrite RAG...\") # Uncomment for verbose logging",
  "# Define prompts for the query rewriting task\nsys_prompt_rw = \"You are an expert query optimizer. Rewrite the user's query to be ideal for vector database retrieval. Focus on key entities, concepts, and relationships. Remove conversational fluff. Output ONLY the rewritten query text.\"\nuser_prompt_rw = f\"Original Query: {test_query}nnRewritten Query:\"\n# Call the LLM to rewrite the query\nresp_rw = client.chat.completions.create(\nmodel=NEBIUS_GENERATION_MODEL, # Can use the generation model for this task too\nmessages=[\n{\"role\": \"system\", \"content\": sys_prompt_rw},\n{\"role\": \"user\", \"content\": user_prompt_rw}\n],\ntemperature=0.1, # Low temp for focused rewrite\nmax_tokens=100,\ntop_p=0.9\n)\n# Clean up the LLM's response to get just the query text\ncandidate_q = resp_rw.choices[0].message.content.strip()\n# Remove potential prefixes like \"Rewritten Query:\" or \"Query:\"\ncandidate_q = re.sub(r'^(rewritten query:|query:)s*', '', candidate_q, flags=re.IGNORECASE).strip('\"')\n# Use the rewritten query only if it's reasonably different and not too short\nif candidate_q and len(candidate_q) > 5 and candidate_q.lower() != test_query.lower():\nrewritten_q = candidate_q",
  "# print(f\"      Using rewritten query: '{rewritten_q}'\") # Uncomment for verbose logging\n# else:\n# print(\"      Rewrite failed, too short, or same as original. Using original query.\") # Uncomment for verbose logging\nexcept Exception as e:\nprint(f\"    Warning: Error during query rewrite: {e}. Using original query.\")\nrewritten_q = test_query # Fallback to original query on error\n# Run evaluation using the (potentially) rewritten query for retrieval\nresult_rewrite = run_and_evaluate(\"Query Rewrite RAG\", rewritten_q, top_k)\nall_results.append(result_rewrite)\n# Strategy 3: Rerank RAG (Simulated)\n# Use original query for retrieval, but simulate the reranking process\nresult_rerank = run_and_evaluate(\"Rerank RAG (Simulated)\", test_query, top_k, use_simulated_rerank=True)\nall_results.append(result_rerank)\nprint(\"n=== RAG Experiment Loop Finished ===\")\nprint(\"-\" * 25)\n### 9. Analysis: Reviewing the Results\nCode:\nprint(\"--- Analyzing Experiment Results ---\")\n# First, check if any results were actually collected\nif not all_results:\nprint(\"No results were generated during the experiment. Cannot perform analysis.\")\nelse:\n# Convert the list of result dictionaries into a Pandas DataFrame\nresults_df = pd.DataFrame(all_results)\nprint(f\"Total results collected: {len(results_df)}\")",
  "# Sort the DataFrame based on the 'avg_score' column in descending order (best first)\n# Use reset_index(drop=True) to get a clean 0-based index after sorting.\nresults_df_sorted = results_df.sort_values(by='avg_score', ascending=False).reset_index(drop=True)\nprint(\"n--- Top 10 Performing Configurations (Sorted by Average Score) ---\")\n# Define the columns we want to display in the summary table\ndisplay_cols = [\n'chunk_size', 'overlap', 'top_k', 'strategy',\n'avg_score', 'faithfulness', 'relevancy', 'similarity_score', # Added similarity\n'time_sec',\n'answer' # Including the answer helps qualitatively assess the best runs\n]\n# Filter out any columns that might not exist (e.g., if an error occurred before population)\ndisplay_cols = [col for col in display_cols if col in results_df_sorted.columns]\n# Display the head (top 10 rows) of the sorted DataFrame using the selected columns\n# The display() function provides richer output in Jupyter environments.\ndisplay(results_df_sorted[display_cols].head(10))\n# --- Summary of the Single Best Run ---\nprint(\"n--- Best Configuration Summary ---\")\n# Check if the sorted DataFrame is not empty before accessing the first row\nif not results_df_sorted.empty:",
  "# Get the first row (index 0), which corresponds to the best score after sorting\nbest_run = results_df_sorted.iloc[0]\n# Print the parameters and results of the best configuration\nprint(f\"Chunk Size: {best_run.get('chunk_size', 'N/A')} words\")\nprint(f\"Overlap: {best_run.get('overlap', 'N/A')} words\")\nprint(f\"Top-K Retrieved: {best_run.get('top_k', 'N/A')} chunks\")\nprint(f\"Strategy: {best_run.get('strategy', 'N/A')}\")",
  "# Use .get(col, default) for robustness in case a column is missing\navg_score = best_run.get('avg_score', 0.0)\nfaithfulness = best_run.get('faithfulness', 0.0)\nrelevancy = best_run.get('relevancy', 0.0)\nsimilarity = best_run.get('similarity_score', 0.0)\ntime_sec = best_run.get('time_sec', 0.0)\nbest_answer = best_run.get('answer', 'N/A')\nprint(f\"---> Average Score (Faith+Rel+Sim): {avg_score:.3f}\")\nprint(f\"      (Faithfulness: {faithfulness:.3f}, Relevancy: {relevancy:.3f}, Similarity: {similarity:.3f})\")\nprint(f\"Time Taken: {time_sec:.2f} seconds\")\nprint(f\"nBest Answer Generated:\")\n# Print the full answer generated by the best configuration\nprint(best_answer)\nelse:\n# Handle the case where no results were successfully processed\nprint(\"Could not determine the best configuration (no valid results found).\")\nprint(\"n--- Analysis Complete --- \")\n### 4. Input Data: The Knowledge Source & Our Question\nCode:",
  "# Our knowledge base: A list of text documents about renewable energy\ncorpus_texts = [\n\"Solar power uses PV panels or CSP systems. PV converts sunlight directly to electricity. CSP uses mirrors to heat fluid driving a turbine. It's clean but varies with weather/time. Storage (batteries) is key for consistency.\", # Doc 0\n\"Wind energy uses turbines in wind farms. It's sustainable with low operating costs. Wind speed varies, siting can be challenging (visual/noise). Offshore wind is stronger and more consistent.\", # Doc 1\n\"Hydropower uses moving water, often via dams spinning turbines. Reliable, large-scale power with flood control/water storage benefits. Big dams harm ecosystems and displace communities. Run-of-river is smaller, less disruptive.\", # Doc 2\n\"Geothermal energy uses Earth's heat via steam/hot water for turbines. Consistent 24/7 power, small footprint. High initial drilling costs, sites are geographically limited.\", # Doc 3\n\"Biomass energy from organic matter (wood, crops, waste). Burned directly or converted to biofuels. Uses waste, provides dispatchable power. Requires sustainable sourcing. Combustion releases emissions (carbon-neutral if balanced by regrowth).\" # Doc 4\n]\n# The question we will ask the RAG system\ntest_query = \"Compare the consistency and environmental impact of solar power versus hydropower.\"",
  "# !!! CRITICAL: The 'True Answer' MUST be derivable ONLY from the corpus_texts above !!!\n# This is our ground truth for evaluation.\ntrue_answer_for_query = \"Solar power's consistency varies with weather and time of day, requiring storage like batteries. Hydropower is generally reliable, but large dams have significant environmental impacts on ecosystems and communities, unlike solar power's primary impact being land use for panels.\"\nprint(f\"Loaded {len(corpus_texts)} documents into our corpus.\")\nprint(f\"Test Query: '{test_query}'\")\nprint(f\"Reference (True) Answer for evaluation: '{true_answer_for_query}'\")\nprint(\"Input data is ready.\")\nprint(\"-\" * 25)\n### 3. Configuration: Setting Up Our Experiment\nCode:\n# --- NebiusAI API Configuration ---\n# It's best practice to store API keys as environment variables rather than hardcoding them.",
  "# Provide your actual key here or set it as an environment variable\nNEBIUS_API_KEY = os.getenv('NEBIUS_API_KEY', None)  # Load API key from environment variable\nif NEBIUS_API_KEY is None:\nprint(\"Warning: NEBIUS_API_KEY not set. Please set it in your environment variables or provide it directly in the code.\")\nNEBIUS_BASE_URL = \"https://api.studio.nebius.com/v1/\"\nNEBIUS_EMBEDDING_MODEL = \"BAAI/bge-multilingual-gemma2\"  # Model for converting text to vector embeddings\nNEBIUS_GENERATION_MODEL = \"deepseek-ai/DeepSeek-V3\"    # LLM for generating the final answers\nNEBIUS_EVALUATION_MODEL = \"deepseek-ai/DeepSeek-V3\"    # LLM used for evaluating the generated answers\n# --- Text Generation Parameters (for RAG answer generation) ---\nGENERATION_TEMPERATURE = 0.1  # Lower values (e.g., 0.1-0.3) make output more focused and deterministic, good for fact-based answers.\nGENERATION_MAX_TOKENS = 400   # Maximum number of tokens (roughly words/sub-words) in the generated answer.\nGENERATION_TOP_P = 0.9        # Nucleus sampling parameter (alternative to temperature, usually fine at default).",
  "# --- Evaluation Prompts (Instructions for the Evaluator LLM) ---\n# Faithfulness: Does the answer stay true to the provided context?\nFAITHFULNESS_PROMPT = \"\"\"\nSystem: You are an objective evaluator. Evaluate the faithfulness of the AI Response compared to the True Answer, considering only the information present in the True Answer as the ground truth.\nFaithfulness measures how accurately the AI response reflects the information in the True Answer, without adding unsupported facts or contradicting it.\nScore STRICTLY using a float between 0.0 and 1.0, based on this scale:\n- 0.0: Completely unfaithful, contradicts or fabricates information.\n- 0.1-0.4: Low faithfulness with significant inaccuracies or unsupported claims.\n- 0.5-0.6: Partially faithful but with noticeable inaccuracies or omissions.\n- 0.7-0.8: Mostly faithful with only minor inaccuracies or phrasing differences.\n- 0.9: Very faithful, slight wording differences but semantically aligned.\n- 1.0: Completely faithful, accurately reflects the True Answer.\nRespond ONLY with the numerical score.\nUser:\nQuery: {question}\nAI Response: {response}\nTrue Answer: {true_answer}\nScore:\"\"\"",
  "# Relevancy: Does the answer directly address the user's query?\nRELEVANCY_PROMPT = \"\"\"\nSystem: You are an objective evaluator. Evaluate the relevance of the AI Response to the specific User Query.\nRelevancy measures how well the response directly answers the user's question, avoiding unnecessary or off-topic information.\nScore STRICTLY using a float between 0.0 and 1.0, based on this scale:\n- 0.0: Not relevant at all.\n- 0.1-0.4: Low relevance, addresses a different topic or misses the core question.\n- 0.5-0.6: Partially relevant, answers only a part of the query or is tangentially related.\n- 0.7-0.8: Mostly relevant, addresses the main aspects of the query but might include minor irrelevant details.\n- 0.9: Highly relevant, directly answers the query with minimal extra information.\n- 1.0: Completely relevant, directly and fully answers the exact question asked.\nRespond ONLY with the numerical score.\nUser:\nQuery: {question}\nAI Response: {response}\nScore:\"\"\"",
  "# --- Parameters to Tune (The experimental variables) ---\nCHUNK_SIZES_TO_TEST = [150, 250]    # List of chunk sizes (in words) to experiment with.\nCHUNK_OVERLAPS_TO_TEST = [30, 50]   # List of chunk overlaps (in words) to experiment with.\nRETRIEVAL_TOP_K_TO_TEST = [3, 5]   # List of 'k' values (number of chunks to retrieve) to test.\n# --- Reranking Configuration (Only used for the Rerank strategy) ---\nRERANK_RETRIEVAL_MULTIPLIER = 3 # For simulated reranking: retrieve K * multiplier chunks initially.\n# --- Validate API Key ---\nprint(\"--- Configuration Check --- \")\nprint(f\"Attempting to load Nebius API Key from environment variable 'NEBIUS_API_KEY'...\")\nif not NEBIUS_API_KEY:\nprint(\"Nebius API Key not found in environment variables.\")\n# Prompt the user securely if the key is not found.\nNEBIUS_API_KEY = getpass.getpass(\"Please enter your Nebius API Key: \")\nelse:\nprint(\"Nebius API Key loaded successfully from environment variable.\")",
  "# Print a summary of key settings for verification\nprint(f\"Models: Embed='{NEBIUS_EMBEDDING_MODEL}', Gen='{NEBIUS_GENERATION_MODEL}', Eval='{NEBIUS_EVALUATION_MODEL}'\")\nprint(f\"Chunk Sizes to Test: {CHUNK_SIZES_TO_TEST}\")\nprint(f\"Overlaps to Test: {CHUNK_OVERLAPS_TO_TEST}\")\nprint(f\"Top-K Values to Test: {RETRIEVAL_TOP_K_TO_TEST}\")\nprint(f\"Generation Temp: {GENERATION_TEMPERATURE}, Max Tokens: {GENERATION_MAX_TOKENS}\")\nprint(\"Configuration ready.\")\nprint(\"-\" * 25)\n### 2. Setup: Importing Libraries\nCode:\nimport os                     # For accessing environment variables (like API keys)\nimport time                   # For timing operations\nimport re                     # For regular expressions (text cleaning)\nimport warnings               # For controlling warning messages\nimport itertools              # For creating parameter combinations easily\nimport getpass                # For securely prompting for API keys if not set\nimport numpy as np            # Numerical library for vector operations\nimport pandas as pd           # Data manipulation library for tables (DataFrames)\nimport faiss                  # Library for fast vector similarity search\nfrom openai import OpenAI     # Client library for Nebius API interaction\nfrom tqdm.notebook import tqdm # Library for displaying progress bars\nfrom sklearn.metrics.pairwise import cosine_similarity # For calculating similarity score",
  "# Configure display options for Pandas DataFrames for better readability\npd.set_option('display.max_colwidth', 150) # Show more text content in table cells\npd.set_option('display.max_rows', 100)     # Display more rows in tables\nwarnings.filterwarnings('ignore', category=FutureWarning) # Suppress specific non-critical warnings\nprint(\"Libraries imported successfully!\")\n### 9. Analysis: Reviewing the Results\nNow that the experiment loop has completed and `all_results` contains the data from each run, we'll use the Pandas library to analyze the findings.\n1.  **Create DataFrame:** Convert the list of result dictionaries (`all_results`) into a Pandas DataFrame for easy manipulation and viewing.\n2.  **Sort Results:** Sort the DataFrame by the `avg_score` (the average of Faithfulness, Relevancy, and Similarity) in descending order, so the best-performing configurations appear first.\n3.  **Display Top Configurations:** Show the top N rows of the sorted DataFrame, including key parameters, scores, and the generated answer, to quickly identify promising settings.\n4.  **Summarize Best Run:** Print a clear summary of the single best-performing configuration based on the average score, showing its parameters, individual scores, time taken, and the full answer it generated.",
  "### 1. Setup: Installing Libraries\nFirst, we need to install the Python packages required for this notebook.\n- `openai`: Interacts with the Nebius API (which uses an OpenAI-compatible interface).\n- `pandas`: For creating and managing data tables (DataFrames).\n- `numpy`: For numerical operations, especially with vectors (embeddings).\n- `faiss-cpu`: For efficient similarity search on vectors (the retrieval part).\n- `ipywidgets`, `tqdm`: For displaying progress bars in Jupyter.\n- `scikit-learn`: For calculating cosine similarity.\n**Remember!** After the installation finishes, you might need to **Restart the Kernel** (or Runtime) for Jupyter/Colab to recognize the newly installed packages. Look for this option in the menu (e.g., 'Kernel' -> 'Restart Kernel...' or 'Runtime' -> 'Restart Runtime').",
  "### 3. Configuration: Setting Up Our Experiment\nHere, we define all the settings and parameters for our experiment directly as Python variables. This makes it easy to see and modify the configuration in one place.\n**Key Configuration Areas:**\n*   **Nebius API Details:** Credentials and model identifiers for connecting to Nebius AI.\n*   **LLM Settings:** Parameters controlling the behavior of the language model during answer generation (e.g., `temperature` for creativity).\n*   **Evaluation Prompts:** The specific instructions (prompts) given to the LLM when it acts as an evaluator for Faithfulness and Relevancy.\n*   **Tuning Parameters:** The different values for chunk size, overlap, and retrieval `top_k` that we want to systematically test.\n*   **Reranking Setting:** Configuration for the simulated reranking strategy.\n### 1. Setup: Installing Libraries\nCode:\n# Install libraries (run this cell only once if needed)\n# !pip install openai pandas numpy faiss-cpu ipywidgets tqdm scikit-learn",
  "# Learning RAG: Testing Configurations Step-by-Step\n## An Educational End-to-End Pipeline with Enhanced Evaluation\nThis notebook is designed as a learning project to understand how different settings impact Retrieval-Augmented Generation (RAG) systems. We'll build and test a pipeline step-by-step using the **Nebius AI API**.\n**What we'll learn:**\n*   How text chunking (`chunk_size`, `chunk_overlap`) affects what the RAG system retrieves.\n*   How the number of retrieved documents (`top_k`) influences the context provided to the LLM.\n*   The difference between three common RAG strategies (Simple, Query Rewrite, Rerank).\n*   How to use an LLM (like Nebius AI) to automatically evaluate the quality of generated answers using multiple metrics: **Faithfulness**, **Relevancy**, and **Semantic Similarity** to a ground truth answer.\n*   How to combine these metrics into an average score for easier comparison.\nWe'll focus on understanding *why* we perform each step and observing the outcomes clearly, with detailed explanations and commented code.\n### 7.\nCore Component: Cosine Similarity Function\nTo evaluate how semantically similar the generated answer is to our ground truth answer, we use **Cosine Similarity**.\nThis metric measures the cosine of the angle between two vectors (in our case, the embedding vectors of the two answers).",
  "### 7. Core Component: Cosine Similarity Function - 4 - A score of **1** means the vectors point in the same direction (maximum similarity).\n- A score of **0** means the vectors are orthogonal (no similarity).\n- A score of **-1** means the vectors point in opposite directions (maximum dissimilarity).\nFor text embeddings, scores typically range from 0 to 1, where higher values indicate greater semantic similarity.\nWe define a function `calculate_cosine_similarity` that takes two text strings, generates their embeddings using the Nebius client, and returns their cosine similarity score.\n### 7.\nCore Component: Cosine Similarity Function\nCode:\ndef calculate_cosine_similarity(text1, text2, client, embedding_model):\n\"\"\"Calculates cosine similarity between the embeddings of two texts.\nArgs:\ntext1 (str): The first text string.\ntext2 (str): The second text string.\nclient (OpenAI): The initialized Nebius AI client.\nembedding_model (str): The name of the embedding model to use.\nReturns:\nfloat: The cosine similarity score (between 0.0 and 1.0), or 0.0 if an error occurs.\n\"\"\"\nif not client:\nprint(\"  Error: Nebius client not available for similarity calculation.\")\nreturn 0.0\nif not text1 or not text2:\n# Handle cases where one or both texts might be empty or None\nreturn 0.0\ntry:",
  "# Generate embeddings for both texts in a single API call if possible\nresponse = client.embeddings.create(model=embedding_model, input=[text1, text2])\n# Extract the embedding vectors\nembedding1 = np.array(response.data[0].embedding)\nembedding2 = np.array(response.data[1].embedding)\n# Reshape vectors to be 2D arrays as expected by cosine_similarity\nembedding1 = embedding1.reshape(1, -1)\nembedding2 = embedding2.reshape(1, -1)\n# Calculate cosine similarity using scikit-learn\n# cosine_similarity returns a 2D array, e.g., [[similarity]], so we extract the value.\nsimilarity_score = cosine_similarity(embedding1, embedding2)[0][0]\n# Clamp the score between 0.0 and 1.0 for safety/consistency\nreturn max(0.0, min(1.0, similarity_score))\nexcept Exception as e:\nprint(f\"  Error calculating cosine similarity: {e}\")\nreturn 0.0 # Return 0.0 in case of any API or calculation errors",
  "# --- Quick Test ---\nprint(\"Defining the 'calculate_cosine_similarity' function.\")\nif client: # Only run test if client is initialized\ntest_sim = calculate_cosine_similarity(\"apple\", \"orange\", client, NEBIUS_EMBEDDING_MODEL)\nprint(f\"Testing similarity function: Similarity between 'apple' and 'orange' = {test_sim:.2f}\")\nelse:\nprint(\"Skipping similarity function test as Nebius client is not initialized.\")\nprint(\"-\" * 25)\n### 6. Core Component: Connecting to Nebius AI\nCode:\nclient = None # Initialize client variable to None globally\nprint(\"Attempting to initialize the Nebius AI client...\")\ntry:\n# Check if the API key is actually available before creating the client\nif not NEBIUS_API_KEY:\nraise ValueError(\"Nebius API Key is missing. Cannot initialize client.\")\n# Create the OpenAI client object, configured for the Nebius API.\nclient = OpenAI(\napi_key=NEBIUS_API_KEY,     # Pass the API key loaded earlier\nbase_url=NEBIUS_BASE_URL  # Specify the Nebius API endpoint\n)\n# Optional: Add a quick test call to verify the client connection,\n# e.g., listing models (if supported and desired). This might incur costs.\n# try:\n#     client.models.list()\n#     print(\"Client connection verified by listing models.\")\n# except Exception as test_e:",
  "#     print(f\"Warning: Could not verify client connection with test call: {test_e}\")\nprint(\"Nebius AI client initialized successfully. Ready to make API calls.\")\nexcept Exception as e:\n# Catch any errors during client initialization (e.g., invalid key, network issues)\nprint(f\"Error initializing Nebius AI client: {e}\")\nprint(\"!!! Execution cannot proceed without a valid client. Please check your API key and network connection. !!!\")\n# Setting client back to None to prevent further attempts if initialization failed\nclient = None\nprint(\"Client setup step complete.\")\nprint(\"-\" * 25)\n### 6. Core Component: Connecting to Nebius AI\nTo use the Nebius AI models (for embedding, generation, evaluation), we need to establish a connection to their API. We use the `openai` Python library, which provides a convenient way to interact with OpenAI-compatible APIs like Nebius.\nWe instantiate an `OpenAI` client object, providing our API key and the specific Nebius API endpoint URL."
]